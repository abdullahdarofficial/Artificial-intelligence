# -*- coding: utf-8 -*-
"""l217512AI-lab4-G1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Tx9DgBxCaFKkQnFupCUBDZSEQ3ZWa227
"""

from google.colab import drive
drive.mount('/content/drive')

def import_matrix_from_file(filepath):
    with open(filepath, 'r') as file:
        matrix = [list(map(lambda x: int(x) if x.isdigit() else x, line.strip())) for line in file]
    return matrix

def is_valid_move(matrix, row, col):
    return 0 <= row < len(matrix) and 0 <= col < len(matrix[0]) and matrix[row][col] != 1

def find_start_and_goal_positions(matrix):
  for i in range(len(matrix)):
    for j in range(len(matrix[0])):
      if matrix[i][j] == 'S':
        s_pos = (i,j)
      elif matrix[i][j] == 'G':
        g_pos = (i,j)
  return s_pos, g_pos

def bfs_for_finding_path(matrix):
  num_rows = len(matrix)
  num_cols = len(matrix[0]) if matrix else 0
  queue = [(s_pos[0], s_pos[1], [])]
  visited = set()

  while(queue):
    row, col, path = queue.pop(0)
    if(row, col) == g_pos:
      return path + [(row, col)]

    visited.add((row,col))
    directions = [(0,1), (1,0), (0,-1), (-1,0)]
    for dr, dc in directions:
      new_row = row + dr
      new_col = col + dc
      if 0 <= new_row < num_rows and 0 <= new_col < num_cols and is_valid_move(matrix, new_row, new_col) and(new_row, new_col) not in visited:
        queue.append((new_row, new_col, path + [(row, col)]))
        visited.add((new_row, new_col))

  return None

def dfs_for_finding_path(matrix):
    num_rows = len(matrix)
    num_cols = len(matrix[0]) if matrix else 0
    stack = [(s_pos[0], s_pos[1], [])]
    visited = set()

    while stack:
        row, col, path = stack.pop()
        if (row, col) == g_pos:
            return path + [(row, col)]

        visited.add((row, col))
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        for dr, dc in directions:
            new_row = row + dr
            new_col = col + dc
            if 0 <= new_row < num_rows and 0 <= new_col < num_cols and is_valid_move(matrix, new_row, new_col) and (new_row, new_col) not in visited:
                stack.append((new_row, new_col, path + [(row, col)]))
                visited.add((new_row, new_col))

    return None

# main

matrix_filepath = '/content/drive/My Drive/sampledata/matrix.txt'
matrix = import_matrix_from_file(matrix_filepath)
print('Matrix:')
for row in matrix:
    print(row)

s_pos, g_pos = find_start_and_goal_positions(matrix)

bfs_path = bfs_for_finding_path(matrix)
if bfs_path:
    print('\nBFS Path:', bfs_path)
else:
    print('\nNo path found for BFS.')

dfs_path = dfs_for_finding_path(matrix)
if dfs_path:
    print('\nDFS Path:', dfs_path)
else:
    print('\nNo path found for DFS.')

def uniform_cost_search_for_graph(graph, start_node, goal_node):
    to_explore = [(0, start_node, [])]
    explored = set()

    while to_explore:
        current_cost, current_state, current_path = to_explore.pop(0)

        if current_state == goal_node:
            return current_path + [current_state], current_cost

        if current_state not in explored:
            explored.add(current_state)

            for neighbor, cost in graph[current_state]:
                if neighbor not in explored:
                    new_cost = current_cost + cost
                    new_path = current_path + [current_state]
                    to_explore.append((new_cost, neighbor, new_path))
                    to_explore.sort()

    return None, float('inf')

# main
graph = {
    'A': [('B', 2), ('C', 3)],
    'B': [('A', 2), ('D', 5)],
    'C': [('A', 3), ('D', 1), ('E', 4)],
    'D': [('B', 5), ('C', 1), ('F', 2)],
    'E': [('C', 4), ('F', 7)],
    'F': [('D', 2), ('E', 7), ('G', 3)],
    'G': [('F', 3), ('H', 5)],
    'H': [('G', 5)]
}


start_node = 'A'
goal_node = 'H'

print('Starting Node: ',start_node)
print('Goal Node: ', goal_node)

path, cost = uniform_cost_search_for_graph(graph, start_node, goal_node)

if path:
    print("Optimal Path:", path)
    print("Total Cost:", cost)
else:
    print("No path found.")

def import_cube_from_file(filepath):
    with open(filepath, 'r') as file:
        cube = [list(map(lambda x: int(x) if x.isdigit() else x, line.strip())) for line in file]
    return cube

def heuristic(pos, goal):
    return abs(pos[0] - goal[0]) + abs(pos[1] - goal[1])

def find_start_and_goal_positions(cube):
    s_pos = None
    g_pos = None
    for i in range(len(cube)):
        for j in range(len(cube[0])):
            if cube[i][j] == 'S':
                s_pos = (i, j)
            elif cube[i][j] == 'G':
                g_pos = (i, j)
    return s_pos, g_pos

def a_star_cube_solver(cube, s_pos, g_pos):
    num_rows = len(cube)
    num_cols = len(cube[0])
    start = s_pos
    goal = g_pos

    priority_queue = [(0, start, [])]
    visited = set()

    while priority_queue:
        priority_queue.sort()
        current_cost, current, path = priority_queue.pop(0)

        if current == goal:
            return path + [current]

        visited.add(current)
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        for dr, dc in directions:
            new_row = current[0] + dr
            new_col = current[1] + dc

            if 0 <= new_row < num_rows and 0 <= new_col < num_cols and (new_row, new_col) not in visited:
                new_position = (new_row, new_col)
                if cube[new_row][new_col] == 1:
                    continue
                elif cube[new_row][new_col] == 2:
                    new_row += dr
                    new_col += dc
                    if not (0 <= new_row < num_rows and 0 <= new_col < num_cols) or cube[new_row][new_col] == 1:
                        continue

                new_cost = len([w for w in path if cube[w[0]][w[1]] == 2])
                new_cost += 1 if cube[new_row][new_col] == 2 else 0
                new_cost += heuristic(new_position, goal)

                priority_queue.append((new_cost, new_position, path + [current]))

    return None

# main
filepath = '/content/drive/My Drive/sampledata/cube.txt'
cube = import_cube_from_file(filepath)
print('Cube:')
for row in cube:
    print(row)

s_pos, g_pos = find_start_and_goal_positions(cube)

cube_solver_path = a_star_cube_solver(cube, s_pos, g_pos)
if cube_solver_path:
    print('\nPath:', cube_solver_path)
else:
    print('\nNo path found.')